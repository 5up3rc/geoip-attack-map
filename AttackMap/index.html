<!DOCTYPE html>

<!-- AUTHOR: Matthew May - mcmay.web@gmail.com -->

<html>
    <head>
        <meta charset="utf-8">
        <title>Attack Map</title>

        <!--SCRIPT LINKS-->
        <script src="http://d3js.org/d3.v3.min.js" charset="utf-8"></script>
        <script src="http://cdn.leafletjs.com/leaflet-0.7/leaflet.js"></script>
        <script src='https://api.mapbox.com/mapbox.js/v2.3.0/mapbox.js'></script>
        <script src='https://api.mapbox.com/mapbox.js/plugins/leaflet-fullscreen/v1.0.1/Leaflet.fullscreen.min.js'></script>

        <!--CSS LINKS-->
        <link href='https://api.mapbox.com/mapbox.js/v2.3.0/mapbox.css' rel='stylesheet' />
        <link href='https://api.mapbox.com/mapbox.js/plugins/leaflet-fullscreen/v1.0.1/leaflet.fullscreen.css' rel='stylesheet' />
        <link href='index.css'rel='stylesheet'/>

    </head>
    <body>

        <div id="map"></div>

        <script type="text/javascript">

            var webSock = new WebSocket("ws:/127.0.0.1:8888/websocket");

            // link map
            L.mapbox.accessToken = "pk.eyJ1IjoibW1heTYwMSIsImEiOiJjaWgyYWU3NWQweWx2d3ltMDl4eGk5eWY1In0.9YoOkALPP7zaoim34ZITxw";
            var map = L.mapbox.map("map", "mmay601.p9if994e", {
                    center: [0, 0], // lat, long
                    zoom: 2
                    });

            // add full screen option
            L.control.fullscreen().addTo(map);

            // add hq coords
            var hqLatLng = new L.LatLng(/*LATITUDE*/37.3845, -122.0881/*LONGITUDE*/);

            // add circle
            L.circle(hqLatLng, 110000, {
                color: 'red',
                fillColor: 'yellow',
                fillOpacity: 0.5,
                }).addTo(map);


            // Append <svg> to map
            var svg = d3.select(map.getPanes().overlayPane).append("svg")
                .attr("class", "leaflet-zoom-animated")
                .attr("width", window.innerWidth)
                .attr("height", window.innerHeight);

            // Append <g> to svg
            //var g = svg.append("g").attr("class", "leaflet-zoom-hide");

            function translateSVG() {
                var viewBoxLeft = document.querySelector("svg.leaflet-zoom-animated").viewBox.animVal.x;
                var viewBoxTop = document.querySelector("svg.leaflet-zoom-animated").viewBox.animVal.y;
                // Resizing width and height in case of window resize
                svg.attr("width", window.innerWidth);
                svg.attr("height", window.innerHeight);

                // Adding the ViewBox attribute to our SVG to contain it
                svg.attr("viewBox", function () {
                    return "" + viewBoxLeft + " " + viewBoxTop + " "  + window.innerWidth + " " + window.innerHeight;
                });
                // Adding the style attribute to our SVG to translate it
                svg.attr("style", function () {
                    return "transform: translate3d(" + viewBoxLeft + "px, " + viewBoxTop + "px, 0px);";
                });
            }

            // Re-draw on reset, this keeps the markers where they should be on reset/zoom
            map.on("moveend", translateSVG);

            function calcMidpoint(x1, y1, x2, y2, bend) {
                if(y2<y1 && x2<x1)
                {
                    var tmpy = y2;
                    var tmpx = x2;
                    x2 = x1;
                    y2 = y1;
                    x1 = tmpx;
                    y1 = tmpy;
                }
                else if(y2<y1) {
            	    y1 = y2 + (y2=y1, 0);
                }
                else if(x2<x1) {
            	    x1 = x2 + (x2=x1, 0);
                }

                var radian = Math.atan(-((y2-y1)/(x2-x1)));
                var r = Math.sqrt(x2-x1) + Math.sqrt(y2-y1);
                var m1 = (x1+x2)/2;
                var m2 = (y1+y2)/2;

                var min = 2.5, max = 7.5;
                //var min = 1, max = 7;
                var arcIntensity = parseFloat((Math.random() * (max - min) + min).toFixed(2));

                if (bend === true) {
            	    var a = Math.floor(m1 - r * arcIntensity * Math.sin(radian));
            	    var b = Math.floor(m2 - r * arcIntensity * Math.cos(radian));
                } else {
            	    var a = Math.floor(m1 + r * arcIntensity * Math.sin(radian));
            	    var b = Math.floor(m2 + r * arcIntensity * Math.cos(radian));
                }

                return {"x":a, "y":b};
            }

            function translateAlong(path) {
                var l = path.getTotalLength();
                return function(i) {
                    return function(t) {
                    // Put in try/catch because sometimes floating point is stupid..
                    try {
                        var p = path.getPointAtLength(t*l);
                        return "translate(" + p.x + "," + p.y + ")";
                    } catch(err){
                        console.log("Caught exception.");
                        return "ERROR";
                        }
                    }
                }
            }

            function handleTraffic(msg, srcPoint, hqPoint, srcLatLng) {
                var fromX = srcPoint['x'];
                var fromY = srcPoint['y'];
                var toX = hqPoint['x'];
                var toY = hqPoint['y'];
                var bendArray = [true, false];
                var bend = bendArray[Math.floor(Math.random() * bendArray.length)];

                lineData = [srcPoint, calcMidpoint(fromX, fromY, toX, toY, bend), hqPoint]

                var lineFunction = d3.svg.line()
                    .interpolate("basis")
                    .x(function(d) {return d.x;})
                    .y(function(d) {return d.y;});

                var lineGraph = svg.append('path')
                                .attr('d', lineFunction(lineData))
                                .attr('opacity', 0.8)
                                .attr('stroke', msg.color)
                                .attr('stroke-width', 2)
                                .attr('fill', 'none');

                if (translateAlong(lineGraph.node()) === 'ERROR') {
                    console.log('translateAlong ERROR')
                    return;
                }

                circleRadius = 6

                // Circle follows the line
                var dot = svg.append('circle')
                    .attr('r', circleRadius)
                    .attr('fill', msg.color)
                    .transition()
                        .duration(700)
                        .ease('ease-in')
                        .attrTween('transform', translateAlong(lineGraph.node()))
                        .each('end', function() {
                                d3.select(this)
                                    .transition()
                                    .duration(500)
                                    .attr('r', circleRadius * 2.5)
                                    .style('opacity', 0)
                                    .remove();
                        });

                var length = lineGraph.node().getTotalLength();
                lineGraph.attr('stroke-dasharray', length + ' ' + length)
                    .attr('stroke-dashoffset', length)
                    .transition()
                        .duration(700)
                        .ease('ease-in')
                        .attr('stroke-dashoffset', 0)
                        .each('end', function() {
                                d3.select(this)
                                    .transition()
                                    .duration(100)
                                    .style('opacity', 0)
                                    .remove();
                        });

                L.circle(srcLatLng, 50000, {
                    color: msg.color,
                    fillColor: msg.color,
                    fillOpacity: 0.2,
                    }).addTo(circles);
            }

            var circles = L.layerGroup().addTo(map);
            var resetCounter = 0;

            //WEBSOCKET STUFF
            webSock.onmessage = function (e) {
                console.log("Got a websocket message...");
                try {
                    var msg = JSON.parse(e.data);
                    console.log(msg);
                    switch(msg.type) {
                        case "Traffic":
                        console.log("Traffic!");

                            if(resetCounter >= 100) {
                                circles.clearLayers();
                                resetCounter = 0;
                            }

                            resetCounter += 1;

                            var srcLatLng = new L.LatLng(msg.src_lat, msg.src_long);
                            var hqPoint = map.latLngToLayerPoint(hqLatLng);
                            var srcPoint = map.latLngToLayerPoint(srcLatLng);
                            console.log('');

                            handleTraffic(msg, srcPoint, hqPoint, srcLatLng);

                            break;
                            //add support for other message types?
                    }
                } catch(err) {
                    console.log(err)
                }
            }
        </script>

    </body>

</html>
